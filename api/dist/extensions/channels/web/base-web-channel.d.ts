import { EventEmitter2 } from '@nestjs/event-emitter';
import { NextFunction, Request, Response } from 'express';
import { Socket } from 'socket.io';
import { Attachment } from '@/attachment/schemas/attachment.schema';
import { AttachmentService } from '@/attachment/services/attachment.service';
import { ChannelService } from '@/channel/channel.service';
import ChannelHandler from '@/channel/lib/Handler';
import { ChannelName } from '@/channel/types';
import { SubscriberCreateDto } from '@/chat/dto/subscriber.dto';
import { Subscriber, SubscriberFull } from '@/chat/schemas/subscriber.schema';
import { AnyMessage, ContentElement, StdOutgoingAttachmentMessage, StdOutgoingButtonsMessage, StdOutgoingEnvelope, StdOutgoingListMessage, StdOutgoingQuickRepliesMessage, StdOutgoingTextMessage } from '@/chat/schemas/types/message';
import { BlockOptions } from '@/chat/schemas/types/options';
import { MessageService } from '@/chat/services/message.service';
import { SubscriberService } from '@/chat/services/subscriber.service';
import { MenuService } from '@/cms/services/menu.service';
import { I18nService } from '@/i18n/services/i18n.service';
import { LoggerService } from '@/logger/logger.service';
import { SettingService } from '@/setting/services/setting.service';
import { SocketRequest } from '@/websocket/utils/socket-request';
import { SocketResponse } from '@/websocket/utils/socket-response';
import { WebsocketGateway } from '@/websocket/websocket.gateway';
import { WEB_CHANNEL_NAME } from './settings';
import { Web } from './types';
import WebEventWrapper from './wrapper';
export default abstract class BaseWebChannelHandler<N extends ChannelName> extends ChannelHandler<N> {
    protected readonly eventEmitter: EventEmitter2;
    protected readonly i18n: I18nService;
    protected readonly subscriberService: SubscriberService;
    readonly attachmentService: AttachmentService;
    protected readonly messageService: MessageService;
    protected readonly menuService: MenuService;
    protected readonly websocketGateway: WebsocketGateway;
    constructor(name: N, settingService: SettingService, channelService: ChannelService, logger: LoggerService, eventEmitter: EventEmitter2, i18n: I18nService, subscriberService: SubscriberService, attachmentService: AttachmentService, messageService: MessageService, menuService: MenuService, websocketGateway: WebsocketGateway);
    init(): void;
    onWebSocketConnection(client: Socket): Promise<boolean | undefined>;
    private formatIncomingHistoryMessage;
    private formatOutgoingHistoryMessage;
    private isIncomingMessage;
    protected formatMessages(messages: AnyMessage[]): Promise<Web.Message[]>;
    protected fetchHistory(req: Request | SocketRequest, until?: Date, n?: number): Promise<Web.Message[]>;
    private pollMessages;
    private validateCors;
    private validateSession;
    protected checkRequest(req: Request | SocketRequest, res: Response | SocketResponse): Promise<void>;
    protected getOrCreateSession(req: Request | SocketRequest): Promise<SubscriberFull>;
    private getMessageQueue;
    protected subscribe(req: Request | SocketRequest, res: Response | SocketResponse): Promise<Partial<import("../../../websocket/pipes/io-message.pipe").IOOutgoingMessage> | Response<any, Record<string, any>>>;
    handleWsUpload(req: SocketRequest): Promise<Attachment | null>;
    handleWebUpload(req: Request, _res: Response): Promise<Attachment | null | undefined>;
    handleUpload(req: Request | SocketRequest, res: Response | SocketResponse): Promise<Attachment | null | undefined>;
    protected getIpAddress(req: Request | SocketRequest): string;
    getChannelAttributes(req: Request | SocketRequest): SubscriberChannelDict[typeof WEB_CHANNEL_NAME];
    _handleEvent(req: Request | SocketRequest, res: Response | SocketResponse): void;
    isSocketRequest(req: Request | SocketRequest): req is SocketRequest;
    handle(req: Request | SocketRequest, res: Response | SocketResponse): Promise<void | Partial<import("../../../websocket/pipes/io-message.pipe").IOOutgoingMessage> | Response<any, Record<string, any>>>;
    generateId(): string;
    _textFormat(message: StdOutgoingTextMessage, _options?: BlockOptions): Web.OutgoingMessageBase;
    _quickRepliesFormat(message: StdOutgoingQuickRepliesMessage, _options?: BlockOptions): Web.OutgoingMessageBase;
    _buttonsFormat(message: StdOutgoingButtonsMessage, _options?: BlockOptions): Web.OutgoingMessageBase;
    _attachmentFormat(message: StdOutgoingAttachmentMessage, _options?: BlockOptions): Promise<Web.OutgoingMessageBase>;
    _formatElements(data: ContentElement[], options: BlockOptions): Promise<Web.MessageElement[]>;
    _listFormat(message: StdOutgoingListMessage, options: BlockOptions): Promise<Web.OutgoingMessageBase>;
    _carouselFormat(message: StdOutgoingListMessage, options: BlockOptions): Promise<Web.OutgoingMessageBase>;
    _formatMessage(envelope: StdOutgoingEnvelope, options: BlockOptions): Promise<Web.OutgoingMessageBase>;
    private broadcast;
    sendMessage(event: WebEventWrapper<N>, envelope: StdOutgoingEnvelope, options: BlockOptions, _context?: any): Promise<{
        mid: string;
    }>;
    sendTypingIndicator(recipient: Subscriber, timeout: number): Promise<void>;
    getSubscriberData(event: WebEventWrapper<N>): Promise<SubscriberCreateDto>;
    hasDownloadAccess(attachment: Attachment, req: Request): Promise<boolean>;
    middleware(req: Request, res: Response, next: NextFunction): Promise<void>;
}
