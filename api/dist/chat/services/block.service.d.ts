import EventWrapper from '@/channel/lib/EventWrapper';
import { ChannelName } from '@/channel/types';
import { ContentService } from '@/cms/services/content.service';
import { NLU } from '@/helper/types';
import { I18nService } from '@/i18n/services/i18n.service';
import { LanguageService } from '@/i18n/services/language.service';
import { PluginService } from '@/plugins/plugins.service';
import { SettingService } from '@/setting/services/setting.service';
import { BaseService } from '@/utils/generics/base-service';
import { BlockDto } from '../dto/block.dto';
import { BlockRepository } from '../repositories/block.repository';
import { Block, BlockFull, BlockPopulate } from '../schemas/block.schema';
import { Label } from '../schemas/label.schema';
import { Subscriber } from '../schemas/subscriber.schema';
import { Context } from '../schemas/types/context';
import { StdOutgoingEnvelope, StdOutgoingSystemEnvelope } from '../schemas/types/message';
import { NlpPattern, PayloadPattern } from '../schemas/types/pattern';
import { Payload } from '../schemas/types/quick-reply';
import { SubscriberContext } from '../schemas/types/subscriberContext';
export declare class BlockService extends BaseService<Block, BlockPopulate, BlockFull, BlockDto> {
    readonly repository: BlockRepository;
    private readonly contentService;
    private readonly settingService;
    private readonly pluginService;
    protected readonly i18n: I18nService;
    protected readonly languageService: LanguageService;
    constructor(repository: BlockRepository, contentService: ContentService, settingService: SettingService, pluginService: PluginService, i18n: I18nService, languageService: LanguageService);
    filterBlocksByChannel<B extends Block | BlockFull>(blocks: B[], channel: ChannelName): B[];
    filterBlocksBySubscriberLabels<B extends Block | BlockFull>(blocks: B[], profile?: Subscriber): B[];
    match(blocks: BlockFull[], event: EventWrapper<any, any>): Promise<BlockFull | undefined>;
    matchPayload(payload: string | Payload, block: BlockFull | Block): PayloadPattern | undefined;
    matchText(text: string, block: Block | BlockFull): (RegExpMatchArray | string)[] | false;
    matchNLP(nlp: NLU.ParseEntities, block: Block | BlockFull): NlpPattern[] | undefined;
    matchOutcome(blocks: Block[], event: EventWrapper<any, any>, envelope: StdOutgoingSystemEnvelope): Block | undefined;
    processTokenReplacements(text: string, context: Context, subscriberContext: SubscriberContext, settings: Settings): string;
    processText(text: string, context: Context, subscriberContext: SubscriberContext, settings: Settings): string;
    getRandom<T>(array: T[]): T;
    checkDeprecatedAttachmentUrl(block: Block | BlockFull): void;
    processMessage(block: Block | BlockFull, context: Context, subscriberContext: SubscriberContext, fallback?: boolean, conversationId?: string): Promise<StdOutgoingEnvelope>;
    handleLabelDelete(labels: Label[]): Promise<void>;
}
